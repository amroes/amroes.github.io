<html><head><style>/* GENERAL */
@import url("https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap");

* {
  margin: 0;
  padding: 0;
}

body {
  font-family: "Poppins", sans-serif;
}

html {
  scroll-behavior: smooth;
}

p {
  color: black; /* Changed to black */
}

/* TRANSITION */
a,
.btn {
  transition: all 300ms ease;
}

/* DESKTOP NAV */
nav,
.nav-links {
  display: flex;
}

nav {
  justify-content: space-around;
  align-items: center;
  height: 17vh;
}

.nav-links {
  gap: 2rem;
  list-style: none;
  font-size: 1.5rem;
}

a {
  color: black;
  text-decoration: none;
  text-decoration-color: white;
}

a:hover {
  color: grey;
  text-decoration: underline;
  text-underline-offset: 1rem;
  text-decoration-color: rgb(181, 181, 181);
}

.logo {
  font-size: 2rem;
}

.logo:hover {
  cursor: default;
}

/* HAMBURGER MENU */
#hamburger-nav {
  display: none;
}

.hamburger-menu {
  position: relative;
  display: inline-block;
}

.hamburger-icon {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 24px;
  width: 30px;
  cursor: pointer;
}

.hamburger-icon span {
  width: 100%;
  height: 2px;
  background-color: black;
  transition: all 0.3 ease-in-out;
}

.menu-links {
  position: absolute;
  top: 100%;
  right: 0;
  background-color: white;
  width: fit-content;
  max-height: 0;
  overflow: hidden;
  transition: all 0.3 ease-in-out;
}

.menu-links a {
  display: block;
  padding: 10px;
  text-align: center;
  font-size: 1.5rem;
  color: black;
  text-decoration: none;
  transition: all 0.3 ease-in-out;
}

.menu-links li {
  list-style: none;
}

.menu-links.open {
  max-height: 300px;
}

.hamburger-icon.open span:first-child {
  transform: rotate(45deg) translate(10px, 5px);
}

.hamburger-icon.open span:nth-child(2) {
  opacity: 0;
}

.hamburger-icon.open span:last-child {
  transform: rotate(-45deg) translate(10px, -5px);
}

.hamburger-icon span:first-child {
  transform: none;
}

.hamburger-icon span:first-child {
  opacity: 1;
}

.hamburger-icon span:first-child {
  transform: none;
}

/* SECTIONS */
section {
  padding-top: 4vh;
  height: 96vh;
  margin: 0 10rem;
  box-sizing: border-box;
  min-height: fit-content;
}

.section-container {
  display: flex;
}

/* PROFILE SECTION */
#profile {
  display: flex;
  justify-content: center;
  gap: 5rem;
  height: 80vh;
}

.section__pic-container {
  display: flex;
  height: 400px;
  width: 400px;
  margin: auto 0;
}

.section__text {
  align-self: center;
  text-align: center;
}

.section__text p {
  font-weight: 600;
}

.section__text__p1 {
  text-align: center;
}

.section__text__p2 {
  font-size: 1.75rem;
  margin-bottom: 1rem;
}

.title {
  font-size: 3rem;
  text-align: center;
}

#socials-container {
  display: flex;
  justify-content: center;
  margin-top: 1rem;
  gap: 1rem;
}

/* ICONS */
.icon {
  cursor: pointer;
  height: 2rem;
}

/* BUTTONS */
.btn-container {
  display: flex;
  justify-content: center;
  gap: 1rem;
}

.btn {
  font-weight: 600;
  transition: all 300ms ease;
  padding: 1rem;
  width: 8rem;
  border-radius: 2rem;
}

.btn-color-1,
.btn-color-2 {
  border: rgb(53, 53, 53) 0.1rem solid;
}

.btn-color-1:hover,
.btn-color-2:hover {
  cursor: pointer;
}

.btn-color-1,
.btn-color-2:hover {
  background: rgb(53, 53, 53);
  color: white;
}

.btn-color-1:hover {
  background: rgb(0, 0, 0);
}

.btn-color-2 {
  background: none;
}

.btn-color-2:hover {
  border: rgb(255, 255, 255) 0.1rem solid;
}

.btn-container {
  gap: 1rem;
}

/* ABOUT SECTION */
#about {
  position: relative;
}

.about-containers {
  gap: 2rem;
  margin-bottom: 2rem;
  margin-top: 2rem;
}

.about-details-container {
  justify-content: center;
  flex-direction: column;
}

.about-containers,
.about-details-container {
  display: flex;
}

.about-pic {
  border-radius: 2rem;
}

.arrow {
  position: absolute;
  right: -5rem;
  bottom: 2.5rem;
}

.details-container {
  padding: 1.5rem;
  flex: 1;
  background: white;
  border-radius: 2rem;
  border: rgb(53, 53, 53) 0.1rem solid;
  border-color: rgb(163, 163, 163);
  text-align: center;
}

.section-container {
  gap: 4rem;
  height: 80%;
}

.section__pic-container {
  height: 400px;
  width: 400px;
  margin: auto 0;
}

/* EXPERIENCE SECTION */
#experience {
  position: relative;
}

.experience-sub-title {
  color: black; /* Changed to black */
  font-weight: 600;
  font-size: 1.75rem;
  margin-bottom: 2rem;
}

.experience-details-container {
  display: flex;
  justify-content: center;
  flex-direction: column;
}

.article-container {
  display: flex;
  text-align: initial;
  flex-wrap: wrap;
  flex-direction: row;
  gap: 2.5rem;
  justify-content: space-around;
}

article {
  display: flex;
  width: 10rem;
  justify-content: space-around;
  gap: 0.5rem;
}

article .icon {
  cursor: default;
}

/* PROJECTS SECTION */
#projects {
  position: relative;
}

.color-container {
  border-color: rgb(163, 163, 163);
  background: rgb(250, 250, 250);
}

.project-img {
  border-radius: 2rem;
  width: 90%;
  height: 90%;
}

.project-title {
  margin: 1rem;
  color: black;
}

.project-btn {
  color: black;
  border-color: rgb(163, 163, 163);
}

/* CONTACT */
#contact {
  display: flex;
  justify-content: center;
  flex-direction: column;
  height: 70vh;
}

.contact-info-upper-container {
  display: flex;
  justify-content: center;
  border-radius: 2rem;
  border: rgb(53, 53, 53) 0.1rem solid;
  border-color: rgb(163, 163, 163);
  background: (250, 250, 250);
  margin: 2rem auto;
  padding: 0.5rem;
}

.contact-info-container {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  margin: 1rem;
}

.contact-info-container p {
  font-size: larger;
}

.contact-icon {
  cursor: default;
}

.email-icon {
  height: 2.5rem;
}

/* FOOTER SECTION */
footer {
  height: 26vh;
  margin: 0 1rem;
}

footer p {
  text-align: center;
}

/* BLOG SECTION */
.blogs-container {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  text-align: center; /* Center align text */
}

.blog-title {
  font-size: 2em;
  font-weight: bold;
  color: black; /* Changed to black */
  margin-bottom: 10px;
}

.blog-date {
  font-size: 0.9em;
  color: black; /* Changed to black */
  margin-bottom: 20px;
}

.blog-description {
  font-size: 1em;
  color: black; /* Changed to black */
  margin-bottom: 20px;
  text-align: left; /* Left align content inside description */
}

.blog-description h1,
.blog-description h2,
.blog-description h3,
.blog-description h4,
.blog-description h5,
.blog-description h6 {
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  font-weight: bold;
  color: black; /* Changed to black */
}

.blog-description p {
  margin-bottom: 1em;
  color: black; /* Changed to black */
}

.blog-description ul,
.blog-description ol {
  margin-bottom: 1em;
  padding-left: 20px;
}

.blog-description li {
  margin-bottom: 0.5em;
  color: black; /* Changed to black */
}

.blog-description a {
  color: #007BFF;
  text-decoration: none;
}

.blog-description a:hover {
  text-decoration: underline;
}

.blog-description pre {
  background-color: #f4f4f4;
  padding: 10px;
  border-radius: 5px;
  overflow-x: auto;
  margin-bottom: 1em;
}

.blog-description code {
  font-family: "Courier New", Courier, monospace;
  font-size: 0.9em;
  color: #c7254e;
  background-color: #f9f2f4;
  padding: 2px 4px;
  border-radius: 3px;
}

.blog-description blockquote {
  border-left: 4px solid #007BFF;
  padding-left: 10px;
  color: black; /* Changed to black */
  margin-bottom: 1em;
}

.blog-description hr {
  border: 0;
  height: 1px;
  background: #ddd;
  margin: 2em 0;
}</style></head><body><hr>
<h2 id="introduction-to-exploit-development-x86-architecture">Introduction to Exploit Development &amp; x86 architecture</h2>
<p>Hello and welcome to the first blog in my <strong>Windows user-mode exploit development</strong> series! If you&#39;re reading this, it means you&#39;re interested in <strong>Windows binary exploitation</strong>. In this series, I’ll take you from <strong>zero to hero</strong>, covering everything from <strong>beginner-friendly fundamentals</strong> to <strong>advanced techniques</strong> for <strong>x86</strong> exploitation.</p>
<p>The series is structured into <strong>four parts</strong>, with this first one designed to build a <strong>strong foundation</strong> by introducing <strong>x86 architecture</strong>, the importance of exploit development, and why it’s such a crucial skill today. We’ll wrap up this part by crafting our very first <strong>vanilla buffer overflow exploit</strong>.</p>
<p>As of now, only <strong>Series 1</strong> is published, but rest assured, the remaining <strong>three</strong> will follow—potentially even more, depending on my research. Stay tuned!</p>
<blockquote>
<p>Before diving into this series, get your windows x86 VM ready along with kali and enjoy the ride :3 </p>
</blockquote>
<h2 id="why-exploit-development-matters">Why Exploit Development Matters</h2>
<p>Exploit development remains a <strong>critical skill</strong> in cybersecurity. Despite years of advancements in <strong>mitigations and security mechanisms</strong>, new <strong>binary exploits</strong> continue to emerge, proving that <strong>no system is completely secure</strong>. Understanding <strong>how vulnerabilities are exploited</strong> allows security researchers, penetration testers, and even defenders to build more <strong>effective protections</strong> and develop <strong>countermeasures</strong> against real-world threats.</p>
<p>In this series, we will be focusing on <strong>x86 exploitation</strong>. The reason for this is simple: <strong>learning exploitation from scratch is significantly easier on x86 than on x64</strong>. The x86 architecture has <strong>simpler calling conventions, fewer registers, and more well-documented legacy exploits</strong>, making it an ideal starting point. Once you grasp the fundamentals of <strong>memory corruption</strong>, <strong>stack overflows</strong>, and <strong>shellcoding</strong> in x86, transitioning to <strong>x64 becomes much easier</strong>, as the core principles remain the same with only structural changes.</p>
<p>Mastering exploit development isn’t just about breaking things—it’s about understanding <strong>how modern security works</strong>, bypassing protections like <strong>DEP, ASLR</strong>, and <strong>stack canaries</strong> (which we’ll cover in upcoming series), and ultimately <strong>thinking like an attacker</strong> to strengthen overall security. Whether you&#39;re aiming for <strong>offensive security, vulnerability research, or bug bounty hunting</strong>, these skills are essential in today’s cybersecurity landscape.</p>
<h2 id="program-memory-stack-fundamentals">Program Memory &amp; Stack Fundamentals</h2>
<p>I had this realization that the majority of the time when my friends were having issues, I would direct them to port their ticket(s) to linux and use the tools there with <code>--debug</code>. The errors thrown here are usually much more helpful and easier to google, and not affected by the instability of Windows.
<img src="https://i.gyazo.com/83ca70027d8d65ea776d2020b38b1df4.png" alt="1"></p>
<p>While there are several key memory areas in a program, for the purpose of this series, we’ll focus mainly on the stack. We won’t go into a deep dive, but you can refer to other resources for more detailed information if needed. Let&#39;s start with the basics:</p>
<p>I believe that the majority of the time, you can perform the same attacks on Active Directory from Linux as you would from Windows, but with the added benefit of being able to debug your issues more easily.</p>
<h3 id="the-stack">The Stack</h3>
<p>The <strong>stack</strong> is a special area of memory used for short-term data storage, specifically for <strong>function calls</strong>, <strong>local variables</strong>, and <strong>control information</strong>. When a thread is running and executing code from the program or DLLs, data is pushed to the stack to keep track of the function calls and their variables. The stack operates on a <strong>Last-In-First-Out (LIFO)</strong> principle, meaning that the most recently added data is the first to be removed.</p>
<ul>
<li><strong>PUSH</strong>: Places an item on the stack.</li>
<li><strong>POP</strong>: Removes the top item from the stack.</li>
</ul>
<p>This structure is essential to understand when dealing with <strong>buffer overflows</strong>, as you’ll manipulate values on the stack to control the program’s flow.</p>
<h3 id="calling-conventions">Calling Conventions</h3>
<p>A <strong>calling convention</strong> defines the low-level mechanism by which functions receive parameters from their caller and how they return values. It determines how arguments are passed, either through <strong>CPU registers</strong> or by being <strong>pushed onto the stack</strong>.</p>
<ul>
<li>The <strong>compiler</strong> typically decides which calling convention to use, but it can be <strong>overridden</strong> by programmers for specific functions if necessary.</li>
<li><strong>Calling conventions</strong> affect <strong>function performance</strong> and <strong>compatibility</strong>, and it’s crucial to understand them when working with <strong>exploitation techniques</strong>, especially in relation to <strong>buffer overflows</strong> and <strong>shellcoding</strong>.</li>
</ul>
<h3 id="function-return-mechanics">Function Return Mechanics</h3>
<p>When a function is called, it executes and then needs to return to the place it was originally called from. To achieve this, the program uses a special piece of data: the <strong>return address</strong>. This address points to the instruction right after the function call, where the program should resume execution once the function finishes.</p>
<ul>
<li><strong>Stack Frame</strong>: When a function is called, the <strong>return address</strong> and any function parameters are pushed onto the stack. This forms what is known as the <strong>stack frame</strong> for that function.</li>
<li><strong>Return Flow</strong>: When the function ends, the <strong>return address</strong> is popped off the stack, and the program execution jumps to that address, resuming where it left off.</li>
</ul>
<p>This mechanism is critical in <strong>exploit development</strong>, as it enables us to control the program&#39;s execution flow, particularly through <strong>stack overflows</strong>.</p>
<h3 id="cpu-x86">CPU x86</h3>
<p>To execute code, the CPU in the x86 architecture utilizes <strong>32-bit registers</strong>. These registers are small, extremely fast storage locations within the CPU, designed to store and manipulate data efficiently
<img src="https://i.gyazo.com/1b54aeea8afdeba562fe7cd92aac72be.png" alt="2"></p>
<h3 id="general-purpose-registers">General purpose Registers</h3>
<p>There are several general-purpose registers in x86, such as <strong>EAX, EBX, ECX, EDX, ESI</strong>, and <strong>EDI</strong>. These registers store temporary data, which can be used for various purposes during program execution. While there is much more to this topic (detailed in various online resources, refer to <a href="https://medium.com/resethacker/introduction-to-the-x86-architecture-275a939f8859">this</a>), the main registers that we&#39;ll focus on are as follows:</p>
<ul>
<li><strong>EAX (Accumulator)</strong>: Used for arithmetic and logical operations.</li>
<li><strong>EBX (Base)</strong>: Serves as a base pointer for memory addressing.</li>
<li><strong>ECX (Counter)</strong>: Commonly used for loop counters and shift/rotate operations.</li>
<li><strong>EDX (Data)</strong>: Used for I/O port addressing and multiplication/division operations.</li>
<li><strong>ESI (Source Index)</strong>: Points to the source data in string operations (e.g., string copying).</li>
<li><strong>EDI (Destination Index)</strong>: Points to the destination data in string operations.</li>
</ul>
<h3 id="esp-the-stack-pointer">ESP - The Stack Pointer</h3>
<p>As previously mentioned, the <strong>stack</strong> is used for storing data, pointers, and function arguments. Since the stack is dynamic and constantly changing during program execution, the <strong>ESP (Stack Pointer)</strong> register keeps track of the most recent location in the stack, effectively pointing to the top of the stack.</p>
<h3 id="ebp-the-base-pointer">EBP - The Base Pointer</h3>
<p>Given that the stack evolves during execution, it can be challenging for a function to locate its stack frame, which contains critical information such as the function&#39;s arguments, local variables, and return address. The <strong>EBP (Base Pointer)</strong> resolves this issue by holding a pointer to the start of the stack frame when a function is called. By referencing <strong>EBP</strong>, a function can easily access its stack frame data using specific <strong>offsets</strong>.</p>
<h3 id="eip-the-instruction-pointer">EIP - The Instruction Pointer</h3>
<p>The <strong>EIP (Instruction Pointer)</strong> is one of the most critical registers when dealing with exploitation. It always holds the address of the next instruction to be executed in the program. Since <strong>EIP</strong> dictates the program’s flow, it becomes a primary target for attackers exploiting memory corruption vulnerabilities such as buffer overflows. By manipulating the <strong>EIP</strong>, attackers can alter the execution flow of the program and redirect it to malicious code.</p>
<blockquote>
<p>Now that we built a basic foundations on x86 architecture, we can start diving into exploiting a basic memory corruption vulnerability, often labeled as vanilla buffer overflow. but before that, let’s explore our main debugger which we are going to work with “windbg”.  and that’s the topic for the next blog. see you there !</p>
</blockquote>
<h3 id="identifying-and-resolving-hosts">Identifying and Resolving Hosts</h3>
<p>Given a domain account with local administrative privileges on a workstation, we can very easily identify the Domain Controller by pinging the domain name. </p>
<pre><code class="lang-powershell">ping <span class="hljs-string">[domain_name]</span>
</code></pre>
<p><img src="https://i.gyazo.com/fc0eaf4baf6935d746ec36ffb91518cf.jpg" alt="1"></p>
</body></html>