<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Exploit Development & x86 Architecture</title>
    <style>
        /* General Styling */
        body {
            background-color: #000000; /* Black background */
            color: #e0e0e0; /* Light gray text */
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            text-align: center; /* Center all text */
        }

        .container {
            max-width: 800px; /* Limit width for better readability */
            margin: 0 auto; /* Center the container */
            padding: 20px;
            text-align: left; /* Left-align text inside container */
        }

        h1, h2, h3, h4, h5, h6 {
            color: #ffffff; /* White headings */
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        h1 {
            font-size: 2.5em; /* Larger title */
        }

        h2 {
            font-size: 2em; /* Slightly smaller for subheadings */
        }

        p {
            margin-bottom: 1.5em; /* Add spacing between paragraphs */
        }

        a {
            color: #1e90ff; /* Blue links */
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        blockquote {
            border-left: 4px solid #1e90ff; /* Blue left border */
            margin: 1.5em 0; /* Add spacing */
            padding-left: 20px;
            color: #b0b0b0; /* Light gray text */
        }

        ul {
            list-style-type: square;
            padding-left: 20px;
            margin-bottom: 1.5em; /* Add spacing */
        }

        img {
            max-width: 100%;
            height: auto;
            margin: 1.5em 0; /* Add spacing */
        }

        hr {
            border: 0;
            height: 1px;
            background: #333; /* Dark gray horizontal rule */
            margin: 20px 0; /* Add spacing */
        }

        code {
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            color: #c7254e; /* Red for code */
            background-color: #f9f2f4; /* Light pink background */
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <hr>
        <h2 id="introduction-to-exploit-development-x86-architecture">Introduction to Exploit Development &amp; x86 Architecture</h2>
        <p>Hello and welcome to the first blog in my <strong>Windows user-mode exploit development</strong> series! If you&#39;re reading this, it means you&#39;re interested in <strong>Windows binary exploitation</strong>. In this series, I’ll take you from <strong>zero to hero</strong>, covering everything from <strong>beginner-friendly fundamentals</strong> to <strong>advanced techniques</strong> for <strong>x86</strong> exploitation.</p>
        <p>The series is structured into <strong>four parts</strong>, with this first one designed to build a <strong>strong foundation</strong> by introducing <strong>x86 architecture</strong>, the importance of exploit development, and why it’s such a crucial skill today. We’ll wrap up this part by crafting our very first <strong>vanilla buffer overflow exploit</strong>.</p>
        <p>As of now, only <strong>Series 1</strong> is published, but rest assured, the remaining <strong>three</strong> will follow—potentially even more, depending on my research. Stay tuned!</p>
        <blockquote>
            <p>Before diving into this series, get your Windows x86 VM ready along with Kali and enjoy the ride :3</p>
        </blockquote>
        <h2 id="why-exploit-development-matters">Why Exploit Development Matters</h2>
        <p>Exploit development remains a <strong>critical skill</strong> in cybersecurity. Despite years of advancements in <strong>mitigations and security mechanisms</strong>, new <strong>binary exploits</strong> continue to emerge, proving that <strong>no system is completely secure</strong>. Understanding <strong>how vulnerabilities are exploited</strong> allows security researchers, penetration testers, and even defenders to build more <strong>effective protections</strong> and develop <strong>countermeasures</strong> against real-world threats.</p>
        <p>In this series, we will be focusing on <strong>x86 exploitation</strong>. The reason for this is simple: <strong>learning exploitation from scratch is significantly easier on x86 than on x64</strong>. The x86 architecture has <strong>simpler calling conventions, fewer registers, and more well-documented legacy exploits</strong>, making it an ideal starting point. Once you grasp the fundamentals of <strong>memory corruption</strong>, <strong>stack overflows</strong>, and <strong>shellcoding</strong> in x86, transitioning to <strong>x64 becomes much easier</strong>, as the core principles remain the same with only structural changes.</p>
        <p>Mastering exploit development isn’t just about breaking things—it’s about understanding <strong>how modern security works</strong>, bypassing protections like <strong>DEP, ASLR</strong>, and <strong>stack canaries</strong> (which we’ll cover in upcoming series), and ultimately <strong>thinking like an attacker</strong> to strengthen overall security. Whether you&#39;re aiming for <strong>offensive security, vulnerability research, or bug bounty hunting</strong>, these skills are essential in today’s cybersecurity landscape.</p>
        <h2 id="program-memory-stack-fundamentals">Program Memory &amp; Stack Fundamentals</h2>
        <p>Before diving into debugging, memory corruption, or writing exploits, we need to understand program memory at the CPU level and familiarize ourselves with some basic definitions. </p>
        <img src="https://i.gyazo.com/83ca70027d8d65ea776d2020b38b1df4.png" alt="1">
        <p>While there are several key memory areas in a program, for the purpose of this series, we’ll focus mainly on the stack. We won’t go into a deep dive, but you can refer to other resources for more detailed information if needed. Let&#39;s start with the basics:</p>
        <h3 id="the-stack">The Stack</h3>
        <p>The <strong>stack</strong> is a special area of memory used for short-term data storage, specifically for <strong>function calls</strong>, <strong>local variables</strong>, and <strong>control information</strong>. When a thread is running and executing code from the program or DLLs, data is pushed to the stack to keep track of the function calls and their variables. The stack operates on a <strong>Last-In-First-Out (LIFO)</strong> principle, meaning that the most recently added data is the first to be removed.</p>
        <ul>
            <li><strong>PUSH</strong>: Places an item on the stack.</li>
            <li><strong>POP</strong>: Removes the top item from the stack.</li>
        </ul>
        <p>This structure is essential to understand when dealing with <strong>buffer overflows</strong>, as you’ll manipulate values on the stack to control the program’s flow.</p>
        <h3 id="calling-conventions">Calling Conventions</h3>
        <p>A <strong>calling convention</strong> defines the low-level mechanism by which functions receive parameters from their caller and how they return values. It determines how arguments are passed, either through <strong>CPU registers</strong> or by being <strong>pushed onto the stack</strong>.</p>
        <ul>
            <li>The <strong>compiler</strong> typically decides which calling convention to use, but it can be <strong>overridden</strong> by programmers for specific functions if necessary.</li>
            <li><strong>Calling conventions</strong> affect <strong>function performance</strong> and <strong>compatibility</strong>, and it’s crucial to understand them when working with <strong>exploitation techniques</strong>, especially in relation to <strong>buffer overflows</strong> and <strong>shellcoding</strong>.</li>
        </ul>
        <h3 id="function-return-mechanics">Function Return Mechanics</h3>
        <p>When a function is called, it executes and then needs to return to the place it was originally called from. To achieve this, the program uses a special piece of data: the <strong>return address</strong>. This address points to the instruction right after the function call, where the program should resume execution once the function finishes.</p>
        <ul>
            <li><strong>Stack Frame</strong>: When a function is called, the <strong>return address</strong> and any function parameters are pushed onto the stack. This forms what is known as the <strong>stack frame</strong> for that function.</li>
            <li><strong>Return Flow</strong>: When the function ends, the <strong>return address</strong> is popped off the stack, and the program execution jumps to that address, resuming where it left off.</li>
        </ul>
        <p>This mechanism is critical in <strong>exploit development</strong>, as it enables us to control the program&#39;s execution flow, particularly through <strong>stack overflows</strong>.</p>
        <h3 id="cpu-x86">CPU x86</h3>
        <p>To execute code, the CPU in the x86 architecture utilizes <strong>32-bit registers</strong>. These registers are small, extremely fast storage locations within the CPU, designed to store and manipulate data efficiently.</p>
        <img src="https://i.gyazo.com/1b54aeea8afdeba562fe7cd92aac72be.png" alt="2">
        <h3 id="general-purpose-registers">General Purpose Registers</h3>
        <p>There are several general-purpose registers in x86, such as <strong>EAX, EBX, ECX, EDX, ESI</strong>, and <strong>EDI</strong>. These registers store temporary data, which can be used for various purposes during program execution. While there is much more to this topic (detailed in various online resources, refer to <a href="https://medium.com/resethacker/introduction-to-the-x86-architecture-275a939f8859">this</a>), the main registers that we&#39;ll focus on are as follows:</p>
        <ul>
            <li><strong>EAX (Accumulator)</strong>: Used for arithmetic and logical operations.</li>
            <li><strong>EBX (Base)</strong>: Serves as a base pointer for memory addressing.</li>
            <li><strong>ECX (Counter)</strong>: Commonly used for loop counters and shift/rotate operations.</li>
            <li><strong>EDX (Data)</strong>: Used for I/O port addressing and multiplication/division operations.</li>
            <li><strong>ESI (Source Index)</strong>: Points to the source data in string operations (e.g., string copying).</li>
            <li><strong>EDI (Destination Index)</strong>: Points to the destination data in string operations.</li>
        </ul>
        <h3 id="esp-the-stack-pointer">ESP - The Stack Pointer</h3>
        <p>As previously mentioned, the <strong>stack</strong> is used for storing data, pointers, and function arguments. Since the stack is dynamic and constantly changing during program execution, the <strong>ESP (Stack Pointer)</strong> register keeps track of the most recent location in the stack, effectively pointing to the top of the stack.</p>
        <h3 id="ebp-the-base-pointer">EBP - The Base Pointer</h3>
        <p>Given that the stack evolves during execution, it can be challenging for a function to locate its stack frame, which contains critical information such as the function&#39;s arguments, local variables, and return address. The <strong>EBP (Base Pointer)</strong> resolves this issue by holding a pointer to the start of the stack frame when a function is called. By referencing <strong>EBP</strong>, a function can easily access its stack frame data using specific <strong>offsets</strong>.</p>
        <h3 id="eip-the-instruction-pointer">EIP - The Instruction Pointer</h3>
        <p>The <strong>EIP (Instruction Pointer)</strong> is one of the most critical registers when dealing with exploitation. It always holds the address of the next instruction to be executed in the program. Since <strong>EIP</strong> dictates the program’s flow, it becomes a primary target for attackers exploiting memory corruption vulnerabilities such as buffer overflows. By manipulating the <strong>EIP</strong>, attackers can alter the execution flow of the program and redirect it to malicious code.</p>
        <blockquote>
            <p>Now that we built a basic foundation on x86 architecture, we can start diving into exploiting a basic memory corruption vulnerability, often labeled as vanilla buffer overflow. But before that, let’s explore our main debugger which we are going to work with: <strong>WinDbg</strong>. That’s the topic for the next blog. See you there!</p>
        </blockquote>
    </div>
</body>
</html>